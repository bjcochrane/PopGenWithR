---
title: <center>Introduction to BEAST</center>
author: <center></center>
date: <center>`r format(Sys.Date(),format="%B %d %Y")`</center>
bibliography: TPG.bib
output: 
    html_document:
       css: Chapter.css
       toc: yes
       toc_depth: 5
---

### Background

So up to this point, we've seen that we've used coalescent theory, starting from a set of nucleotide sequences, to make inferences about past population history, and in fact we managed to achieve some at least semi-plausible results.  However, none of the work we have done, either in class or in lab, would even begin to appropach publishable standards.  Think again what our work has been based on:

1.  We assumed the phylogeny, based as it was on progressively grouping similar sequences, was the true gene geneaolgy.
2.  We assumed that "a mutation is a mutation is a mutation" (more on this in a minute).
3.  We assumed that the substitution rate was constant with time.

With those assumptions, we found that we could take a Bayesian approach, starting with the coalescent intervals derived from the tree, and find a distribution of values for N0 . . . N(TMRCA) that best fit the data.  But in fact, as we shall see, there is uncertainty in all three of our assumptions, so what we really want to do is something like the following:

1.  Select a model of mutation that is appropriate for our data
2.  Select a "molecular clock" model that best relates our mutation model to units of time.
3.  Based on those, generate a *distribution* of gene geneaologies that best explain our data
4.  Use that posterior distribution to estimate the gene genealogy, and from that do our Skyline (or other analyses).

BEAST stands for Bayesian Evolutionary Analysis by Sampling Trees - as its name implies, it does all of the following.  It is an incredibly complex program, but if managed correctly, it can be very powerful.  Thus, before delving into the actual workings of the program, we need to get at at least a few of the underpinnings.

### Dealing with Forests of Trees

As we shall see, the output of BEAST consists of two files - one contains trees that were accepted as part of the posterior distribution of trees, drawn from the prior distribution that we specified.  As an illustration, we will very simplistically at part of the output of a simple BEAST run, performed on some simulated data generated by ms and ms2dna.  We've done this before - we are simulating 10 sequences of length 703 with 15 segregating sites

```{r,eval=FALSE}
system("ms 10 1 -s 15 -r 0 703 -seed 1 2 3 | ms2dna >./BEAST/demo1.fasta")
```

We can visualize them in the usual way:

```{r}
seqs <-read.FASTA("./BEAST/demo1.fasta")
image.DNAbin(as.matrix(seqs))
```

.  However, rather than staying in R, we will detour (in class) to the BEAST pipeline, doing the following:

1.  Load the data into BEAUTi, the program that prepares the model for BEAST analysis.  In so doing, we will, with two exceptions.  First, we will specify that we want to use a constant size coalescent model as our prior distribution of trees.  Second,   We will reduce the number of MCMC cycles to 1,000,000 and specify a burn-in (early trees we discard) of 100,000.  Note also that we will only save every 1000th tree.
2.  Run BEAST
3.  Return to R to see some of what we got.



We now return to look at the output.  All of it was stored (at our choosing) in the folder BEAST.  Its contents are now

```{r}
list.files("./BEAST")
```

The key files are demo1.log and demo1.trees.  Our focus for now will be on the trees.  They are stored in what is called a "nexus" format, and they can be easily read by R.

```{r}
trees <-read.nexus("./BEAST/demo1.trees")
length(trees)
```

So we see we have `r length(trees)` of them.  What we can now do is to sample a few of them and look at their topology:

```{r}
par(mfrow=c(2,2))
s <-sample(length(trees),4)
x <-sapply(s, function(x) plot(trees[[x]]))

```

Since both BEAST and our sampling in R are stochastic in nature, the output will vary from run to run.  However, notice a few things:

1.  The overall topology of the trees are quite similar.  This is to be expected - remember that they were all generated from the same data set, and that furthermore, BEAST has generated (mysteriously at this point) a posterior distribution consisting of trees with the highest likelihood of being the actual one.
2.  The big problem is that, while the nodes mostly connect the same samples, the branch lengths (and the relative timing of the nodes) vary.  This is a problem - after all, those are what we are using in our coalescent analysis.  This can be visualized by plotting the same four trees, only telling R to ignore branch lengths:

```{r}
x <-sapply(s, function(x) plot(trees[[x]],use.edge.length=FALSE))
par(mfrow=c(1,1))
```

Now we see they are much more similar (although still not identical).

So obviously, at this point we need to think more about where the distribution of branch lengths came from.  To do so, we need to diverge into mutation theory.


